{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tarea Unidad 1 - DANIEL TRUJILLO Documentacion de la Unidad 1. Este proyecto integra Python, Pruebas y Sandbox. Contenido: Elementos de python Ejecucion y depuracion del codigo Pruebas de codigo Sandbox Conclusiones 1. Elementos de python Esta secci\u00f3n contiene la documentaci\u00f3n inicial del archivo lavadero.py, realizada al comienzo del desarrollo. En ella se describe la estructura b\u00e1sica de la clase Lavadero y sus componentes principales. Este documento representa la primera aproximaci\u00f3n a la comprensi\u00f3n del sistema, sentando las bases para el posterior trabajo de implementaci\u00f3n, depuraci\u00f3n y pruebas que se desarrollar\u00e1 en las siguientes etapas del proyecto. 2. Ejecucion y depuracion del codigo Esta documentaci\u00f3n describe el proceso de ejecuci\u00f3n y depuraci\u00f3n del c\u00f3digo principal del sistema de lavadero automatizado. El objetivo fue validar el funcionamiento integral de la aplicaci\u00f3n mediante la ejecuci\u00f3n controlada de los casos de uso definidos. Inicialmente, se prepar\u00f3 el entorno de desarrollo creando y activando un entorno virtual para aislar las dependencias del proyecto. Posteriormente, se ejecut\u00f3 el programa principal identificando un error en uno de los ejemplos de uso. Tras analizar el fallo, se corrigi\u00f3 un par\u00e1metro incorrecto en la llamada a la funci\u00f3n, lo que permiti\u00f3 que todos los ejemplos se ejecutaran correctamente y mostraran los resultados esperados. 3. Pruebas Esta documentaci\u00f3n describe el proceso de implementaci\u00f3n y validaci\u00f3n de las pruebas unitarias para el sistema de control de un lavadero automatizado. El objetivo principal fue ejecutar y depurar un conjunto de 14 tests predefinidos que verifican el comportamiento completo del sistema, desde su estado inicial hasta los flujos de trabajo con diversas opciones de servicio. La ejecuci\u00f3n exitosa de todos los tests al final del proceso confirma que el sistema cumple con los requisitos funcionales, maneja correctamente las excepciones y calcula con precisi\u00f3n los ingresos seg\u00fan las opciones de servicio seleccionadas por el cliente. 4. Sandbox Esta documentaci\u00f3n describe el proceso de ejecuci\u00f3n de c\u00f3digo Python en un entorno sandbox utilizando Firejail. El objetivo fue crear un ambiente aislado y seguro para probar aplicaciones sin afectar al sistema principal. El uso de Firejail permiti\u00f3 ejecutar c\u00f3digo de manera segura, manteniendo el sistema host protegido de posibles efectos no deseados durante las pruebas de desarrollo. 5. Conclusiones Esta reflexi\u00f3n analiza la relaci\u00f3n entre los lenguajes de programaci\u00f3n y la seguridad del software, tomando como punto de partida la met\u00e1fora de Bruce Schneier sobre las cerraduras y los lenguajes. Tras estudiar el material de la Unidad 1, se examina c\u00f3mo diferentes lenguajes implementan o no las medidas de protecci\u00f3n integradas y c\u00f3mo estas afectan la seguridad final de las aplicaciones. Finalmente, se presenta una tabla comparativa que resume las caracter\u00edsticas de seguridad, vulnerabilidades comunes y recomendaciones de uso para cada lenguaje analizado. Repositorio de github : Github de Daniel Autor Daniel Trujillo Martin","title":"Tarea Unidad 1 - DANIEL TRUJILLO"},{"location":"#tarea-unidad-1-daniel-trujillo","text":"Documentacion de la Unidad 1. Este proyecto integra Python, Pruebas y Sandbox. Contenido: Elementos de python Ejecucion y depuracion del codigo Pruebas de codigo Sandbox Conclusiones","title":"Tarea Unidad 1 - DANIEL TRUJILLO"},{"location":"#1-elementos-de-python","text":"Esta secci\u00f3n contiene la documentaci\u00f3n inicial del archivo lavadero.py, realizada al comienzo del desarrollo. En ella se describe la estructura b\u00e1sica de la clase Lavadero y sus componentes principales. Este documento representa la primera aproximaci\u00f3n a la comprensi\u00f3n del sistema, sentando las bases para el posterior trabajo de implementaci\u00f3n, depuraci\u00f3n y pruebas que se desarrollar\u00e1 en las siguientes etapas del proyecto.","title":"1. Elementos de python"},{"location":"#2-ejecucion-y-depuracion-del-codigo","text":"Esta documentaci\u00f3n describe el proceso de ejecuci\u00f3n y depuraci\u00f3n del c\u00f3digo principal del sistema de lavadero automatizado. El objetivo fue validar el funcionamiento integral de la aplicaci\u00f3n mediante la ejecuci\u00f3n controlada de los casos de uso definidos. Inicialmente, se prepar\u00f3 el entorno de desarrollo creando y activando un entorno virtual para aislar las dependencias del proyecto. Posteriormente, se ejecut\u00f3 el programa principal identificando un error en uno de los ejemplos de uso. Tras analizar el fallo, se corrigi\u00f3 un par\u00e1metro incorrecto en la llamada a la funci\u00f3n, lo que permiti\u00f3 que todos los ejemplos se ejecutaran correctamente y mostraran los resultados esperados.","title":"2. Ejecucion y depuracion del codigo"},{"location":"#3-pruebas","text":"Esta documentaci\u00f3n describe el proceso de implementaci\u00f3n y validaci\u00f3n de las pruebas unitarias para el sistema de control de un lavadero automatizado. El objetivo principal fue ejecutar y depurar un conjunto de 14 tests predefinidos que verifican el comportamiento completo del sistema, desde su estado inicial hasta los flujos de trabajo con diversas opciones de servicio. La ejecuci\u00f3n exitosa de todos los tests al final del proceso confirma que el sistema cumple con los requisitos funcionales, maneja correctamente las excepciones y calcula con precisi\u00f3n los ingresos seg\u00fan las opciones de servicio seleccionadas por el cliente.","title":"3. Pruebas"},{"location":"#4-sandbox","text":"Esta documentaci\u00f3n describe el proceso de ejecuci\u00f3n de c\u00f3digo Python en un entorno sandbox utilizando Firejail. El objetivo fue crear un ambiente aislado y seguro para probar aplicaciones sin afectar al sistema principal. El uso de Firejail permiti\u00f3 ejecutar c\u00f3digo de manera segura, manteniendo el sistema host protegido de posibles efectos no deseados durante las pruebas de desarrollo.","title":"4. Sandbox"},{"location":"#5-conclusiones","text":"Esta reflexi\u00f3n analiza la relaci\u00f3n entre los lenguajes de programaci\u00f3n y la seguridad del software, tomando como punto de partida la met\u00e1fora de Bruce Schneier sobre las cerraduras y los lenguajes. Tras estudiar el material de la Unidad 1, se examina c\u00f3mo diferentes lenguajes implementan o no las medidas de protecci\u00f3n integradas y c\u00f3mo estas afectan la seguridad final de las aplicaciones. Finalmente, se presenta una tabla comparativa que resume las caracter\u00edsticas de seguridad, vulnerabilidades comunes y recomendaciones de uso para cada lenguaje analizado. Repositorio de github : Github de Daniel","title":"5. Conclusiones"},{"location":"#autor","text":"Daniel Trujillo Martin","title":"Autor"},{"location":"Actividad-Elementos-Programa-Python-Daniel/","text":"Actividad-Elementos-Programa-Python Voy a hacer una documentacion de el archivo lavadero.py 1.Cuando se crea un lavadero, \u00e9ste no tiene ingresos, no est\u00e1 ocupado, est\u00e1 en fase 0 y todas las opciones de lavado (prelavado a mano, secado a mano y encerado) est\u00e1n puestas a false. 2.Cuando se intenta comprar un lavado con encerado pero sin secado a mano, se produce una IllegalArgumentException. 3.Cuando se intenta hacer un lavado mientras que otro ya est\u00e1 en marcha, se produce una IllegalStateException. 4.Si seleccionamos un lavado con prelavado a mano, los ingresos de lavadero son 6,50\u20ac. 5.Si seleccionamos un lavado con secado a mano, los ingresos son 6,00\u20ac. 6.Si seleccionamos un lavado con secado a mano y encerado, los ingresos son 7,20\u20ac. 7.Si seleccionamos un lavado con prelavado a mano y secado a mano, los ingresos son 7,50\u20ac. 8.Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, los ingresos son 8,70\u20ac. 9.Si seleccionamos un lavado sin extras y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 6, 0. 10.Si seleccionamos un lavado con prelavado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 6, 0. 11.Si seleccionamos un lavado con secado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 0.12. 12.Si seleccionamos un lavado con secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0. 13.Si seleccionamos un lavado con prelavado a mano y secado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 0. 14.Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0. # lavadero.py Este bloque crea la clase Lavadero y define n\u00fameros fijos para cada fase del lavado class Lavadero: \"\"\" Simula el estado y las operaciones de un t\u00fanel de lavado de coches. Cumple con los requisitos de estado, avance de fase y reglas de negocio. \"\"\" FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 Cuando se crea un nuevo lavadero, este m\u00e9todo pone todo a cero: sin dinero, inactivo, libre y sin extras seleccionados. def __init__(self): \"\"\" Constructor de la clase. Inicializa el lavadero. Cumple con el requisito 1. \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar() Permiten leer el estado del lavadero desde fuera (por ejemplo lavadero.fase) pero nadie puede cambiarlo directamente. Es la forma segura de consultar los datos privados @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado Deja el lavadero completamente limpio y libre cuando el coche ya ha terminado todo el proceso. def terminar(self): self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False Aqu\u00ed llega un nuevo cliente. Se comprueba que el t\u00fanel est\u00e9 libre y que no pida encerado sin secado a mano. Si todo est\u00e1 bien, se marcan las opciones y el lavadero pasa a estar ocupado def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado, validando reglas de negocio. :raises RuntimeError: Si el lavadero est\u00e1 ocupado (Requisito 3). :raises ValueError: Si se intenta encerar sin secado a mano (Requisito 2). \"\"\" if self.__ocupado: raise RuntimeError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado Calcula cu\u00e1nto cuesta este lavado seg\u00fan los extras y lo suma al dinero total del d\u00eda. def _cobrar(self): \"\"\" Calcula y a\u00f1ade los ingresos seg\u00fan las opciones seleccionadas (Requisitos 4-8). Precio base: 5.00\u20ac (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac) \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.20 if self.__encerado: coste_lavado += 1.00 self.__ingresos += coste_lavado return coste_lavado Es el coraz\u00f3n del programa. Cada vez que lo llamas, el lavadero pasa al siguiente paso: cobrar \u2192 prelavado (si toca) \u2192 agua \u2192 jab\u00f3n \u2192 rodillos \u2192 secado \u2192 encerado (si toca) \u2192 terminar. def avanzarFase(self): if not self.__ocupado: return if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_AUTOMATICO else: self.__fase = self.FASE_SECADO_MANO elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() elif self.__fase == self.FASE_SECADO_MANO: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\") Convierte el n\u00famero de fase en un texto bonito para que se entienda al verlo por pantalla def imprimir_fase(self): fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\") Muestra absolutamente todo lo que est\u00e1 pasando en el lavadero en un momento dado. Ideal para ver c\u00f3mo evoluciona. def imprimir_estado(self): print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\") # Esta funci\u00f3n es \u00fatil para pruebas unitarias, no es parte del lavadero real # nos crea un array con las fases visitadas en un ciclo completo Solo se usa en pruebas autom\u00e1ticas. Ejecuta un lavado completo de una vez y devuelve la lista exacta de fases por las que pas\u00f3 (muy \u00fatil para comprobar que todo funciona bien). def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\"Ejecuta un ciclo completo y devuelve la lista de fases visitadas.\"\"\" self.lavadero.hacerLavado(prelavado, secado, encerado) fases_visitadas = [self.lavadero.fase] while self.lavadero.ocupado: # Usamos un l\u00edmite de pasos para evitar bucles infinitos en caso de error if len(fases_visitadas) > 15: raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\") self.lavadero.avanzarFase() fases_visitadas.append(self.lavadero.fase) return fases_visitadas","title":"Elementos Python"},{"location":"Actividad-Elementos-Programa-Python-Daniel/#actividad-elementos-programa-python","text":"Voy a hacer una documentacion de el archivo lavadero.py 1.Cuando se crea un lavadero, \u00e9ste no tiene ingresos, no est\u00e1 ocupado, est\u00e1 en fase 0 y todas las opciones de lavado (prelavado a mano, secado a mano y encerado) est\u00e1n puestas a false. 2.Cuando se intenta comprar un lavado con encerado pero sin secado a mano, se produce una IllegalArgumentException. 3.Cuando se intenta hacer un lavado mientras que otro ya est\u00e1 en marcha, se produce una IllegalStateException. 4.Si seleccionamos un lavado con prelavado a mano, los ingresos de lavadero son 6,50\u20ac. 5.Si seleccionamos un lavado con secado a mano, los ingresos son 6,00\u20ac. 6.Si seleccionamos un lavado con secado a mano y encerado, los ingresos son 7,20\u20ac. 7.Si seleccionamos un lavado con prelavado a mano y secado a mano, los ingresos son 7,50\u20ac. 8.Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, los ingresos son 8,70\u20ac. 9.Si seleccionamos un lavado sin extras y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 6, 0. 10.Si seleccionamos un lavado con prelavado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 6, 0. 11.Si seleccionamos un lavado con secado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 0.12. 12.Si seleccionamos un lavado con secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0. 13.Si seleccionamos un lavado con prelavado a mano y secado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 0. 14.Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0. # lavadero.py Este bloque crea la clase Lavadero y define n\u00fameros fijos para cada fase del lavado class Lavadero: \"\"\" Simula el estado y las operaciones de un t\u00fanel de lavado de coches. Cumple con los requisitos de estado, avance de fase y reglas de negocio. \"\"\" FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 Cuando se crea un nuevo lavadero, este m\u00e9todo pone todo a cero: sin dinero, inactivo, libre y sin extras seleccionados. def __init__(self): \"\"\" Constructor de la clase. Inicializa el lavadero. Cumple con el requisito 1. \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar() Permiten leer el estado del lavadero desde fuera (por ejemplo lavadero.fase) pero nadie puede cambiarlo directamente. Es la forma segura de consultar los datos privados @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado Deja el lavadero completamente limpio y libre cuando el coche ya ha terminado todo el proceso. def terminar(self): self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False Aqu\u00ed llega un nuevo cliente. Se comprueba que el t\u00fanel est\u00e9 libre y que no pida encerado sin secado a mano. Si todo est\u00e1 bien, se marcan las opciones y el lavadero pasa a estar ocupado def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado, validando reglas de negocio. :raises RuntimeError: Si el lavadero est\u00e1 ocupado (Requisito 3). :raises ValueError: Si se intenta encerar sin secado a mano (Requisito 2). \"\"\" if self.__ocupado: raise RuntimeError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado Calcula cu\u00e1nto cuesta este lavado seg\u00fan los extras y lo suma al dinero total del d\u00eda. def _cobrar(self): \"\"\" Calcula y a\u00f1ade los ingresos seg\u00fan las opciones seleccionadas (Requisitos 4-8). Precio base: 5.00\u20ac (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac) \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.20 if self.__encerado: coste_lavado += 1.00 self.__ingresos += coste_lavado return coste_lavado Es el coraz\u00f3n del programa. Cada vez que lo llamas, el lavadero pasa al siguiente paso: cobrar \u2192 prelavado (si toca) \u2192 agua \u2192 jab\u00f3n \u2192 rodillos \u2192 secado \u2192 encerado (si toca) \u2192 terminar. def avanzarFase(self): if not self.__ocupado: return if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_AUTOMATICO else: self.__fase = self.FASE_SECADO_MANO elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() elif self.__fase == self.FASE_SECADO_MANO: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\") Convierte el n\u00famero de fase en un texto bonito para que se entienda al verlo por pantalla def imprimir_fase(self): fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\") Muestra absolutamente todo lo que est\u00e1 pasando en el lavadero en un momento dado. Ideal para ver c\u00f3mo evoluciona. def imprimir_estado(self): print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\") # Esta funci\u00f3n es \u00fatil para pruebas unitarias, no es parte del lavadero real # nos crea un array con las fases visitadas en un ciclo completo Solo se usa en pruebas autom\u00e1ticas. Ejecuta un lavado completo de una vez y devuelve la lista exacta de fases por las que pas\u00f3 (muy \u00fatil para comprobar que todo funciona bien). def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\"Ejecuta un ciclo completo y devuelve la lista de fases visitadas.\"\"\" self.lavadero.hacerLavado(prelavado, secado, encerado) fases_visitadas = [self.lavadero.fase] while self.lavadero.ocupado: # Usamos un l\u00edmite de pasos para evitar bucles infinitos en caso de error if len(fases_visitadas) > 15: raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\") self.lavadero.avanzarFase() fases_visitadas.append(self.lavadero.fase) return fases_visitadas","title":"Actividad-Elementos-Programa-Python"},{"location":"Conclusion/","text":"Reflexi\u00f3n personal: Medidas de seguridad en los lenguajes de programaci\u00f3n La frase de Bruce Schneier que aparece al principio de la unidad me parece super acertada: El lenguaje que elijas para programar es como la cerradura de tu casa De eso depende mucho la seguridad de lo que construyas. Despu\u00e9s de leer el material de la Unidad 1 , me ha quedado claro que no todos los lenguajes tienen el mismo nivel de protecci\u00f3n contra errores que luego pueden convertirse en vulnerabilidades. Por ejemplo, los lenguajes de bajo nivel como C o el ensamblador dan mucho control, pero no te ayudan casi nada con la seguridad. Todo lo tienes que gestionar t\u00fa: la memoria, los punteros... Un despiste y tienes un problema, que puede ser una vulnerabilidad peligrosa. En cambio, lenguajes de alto nivel como Python o Java te quitan mucho peso de encima. Eso evita un mont\u00f3n de errores cl\u00e1sicos. Java va m\u00e1s all\u00e1 con su m\u00e1quina virtual: verifica el bytecode, tiene sandbox, controla los accesos... Es m\u00e1s dif\u00edcil que un programa Java tenga ciertos tipos de fallos de seguridad por dise\u00f1o. Luego est\u00e1n los lenguajes m\u00e1s modernos como Rust, que me parece impresionante. Lo que m\u00e1s llama la atenci\u00f3n es que te obliga a manejar la memoria de forma segura desde el momento de compilar. B\u00e1sicamente, elimina en tiempo de compilaci\u00f3n errores que en C aparecer\u00edan en ejecuci\u00f3n y podr\u00edan ser explotados. Go tambi\u00e9n ayuda bastante con su garbage collector y el detector de race conditions, aunque no llega al nivel de Rust. Al final, creo que para proyectos donde la seguridad es cr\u00edtica, merece la pena elegir lenguajes que incorporen protecciones de por si. No digo que abandonemos las de bajo nivel del todo, porque a veces hace falta para ciertas cosas de bajo nivel, pero siempre con mucho cuidado. Para la mayor\u00eda de aplicaciones nuevas, yo aplicaria Rust o Java o Go o python no tengo ni idea de como se usan pero son las mas seguras de usar (De python se algo mas pero tampoco gran cosa). Tabla comparativa de seguridad Lenguaje Tipo/Nivel Medidas de seguridad principales Vulnerabilidades comunes Recomendaci\u00f3n C Compilado/Bajo Ninguna autom\u00e1tica (gesti\u00f3n manual) Buffer overflow, use-after-free Solo para componentes cr\u00edticos de bajo nivel con auditor\u00edas exhaustivas Python Interpretado/Alto Garbage collection, m\u00f3dulos seguros Inyecciones, errores runtime Excelente para scripting y prototipado seguro Java H\u00edbrido/Alto Verificaci\u00f3n bytecode, sandbox JVM Deserializaci\u00f3n insegura Ideal para aplicaciones enterprise Rust Compilado/Alto Ownership, borrow checker (memory safety) Muy pocas (seguro por dise\u00f1o) Preferido para software cr\u00edtico y seguro Go Compilado/Alto Garbage collection, race detector Errores de concurrencia menores Bueno para servicios y microservicios","title":"Conclusiones"},{"location":"Conclusion/#reflexion-personal-medidas-de-seguridad-en-los-lenguajes-de-programacion","text":"La frase de Bruce Schneier que aparece al principio de la unidad me parece super acertada: El lenguaje que elijas para programar es como la cerradura de tu casa De eso depende mucho la seguridad de lo que construyas. Despu\u00e9s de leer el material de la Unidad 1 , me ha quedado claro que no todos los lenguajes tienen el mismo nivel de protecci\u00f3n contra errores que luego pueden convertirse en vulnerabilidades. Por ejemplo, los lenguajes de bajo nivel como C o el ensamblador dan mucho control, pero no te ayudan casi nada con la seguridad. Todo lo tienes que gestionar t\u00fa: la memoria, los punteros... Un despiste y tienes un problema, que puede ser una vulnerabilidad peligrosa. En cambio, lenguajes de alto nivel como Python o Java te quitan mucho peso de encima. Eso evita un mont\u00f3n de errores cl\u00e1sicos. Java va m\u00e1s all\u00e1 con su m\u00e1quina virtual: verifica el bytecode, tiene sandbox, controla los accesos... Es m\u00e1s dif\u00edcil que un programa Java tenga ciertos tipos de fallos de seguridad por dise\u00f1o. Luego est\u00e1n los lenguajes m\u00e1s modernos como Rust, que me parece impresionante. Lo que m\u00e1s llama la atenci\u00f3n es que te obliga a manejar la memoria de forma segura desde el momento de compilar. B\u00e1sicamente, elimina en tiempo de compilaci\u00f3n errores que en C aparecer\u00edan en ejecuci\u00f3n y podr\u00edan ser explotados. Go tambi\u00e9n ayuda bastante con su garbage collector y el detector de race conditions, aunque no llega al nivel de Rust. Al final, creo que para proyectos donde la seguridad es cr\u00edtica, merece la pena elegir lenguajes que incorporen protecciones de por si. No digo que abandonemos las de bajo nivel del todo, porque a veces hace falta para ciertas cosas de bajo nivel, pero siempre con mucho cuidado. Para la mayor\u00eda de aplicaciones nuevas, yo aplicaria Rust o Java o Go o python no tengo ni idea de como se usan pero son las mas seguras de usar (De python se algo mas pero tampoco gran cosa).","title":"Reflexi\u00f3n personal: Medidas de seguridad en los lenguajes de programaci\u00f3n"},{"location":"Conclusion/#tabla-comparativa-de-seguridad","text":"Lenguaje Tipo/Nivel Medidas de seguridad principales Vulnerabilidades comunes Recomendaci\u00f3n C Compilado/Bajo Ninguna autom\u00e1tica (gesti\u00f3n manual) Buffer overflow, use-after-free Solo para componentes cr\u00edticos de bajo nivel con auditor\u00edas exhaustivas Python Interpretado/Alto Garbage collection, m\u00f3dulos seguros Inyecciones, errores runtime Excelente para scripting y prototipado seguro Java H\u00edbrido/Alto Verificaci\u00f3n bytecode, sandbox JVM Deserializaci\u00f3n insegura Ideal para aplicaciones enterprise Rust Compilado/Alto Ownership, borrow checker (memory safety) Muy pocas (seguro por dise\u00f1o) Preferido para software cr\u00edtico y seguro Go Compilado/Alto Garbage collection, race detector Errores de concurrencia menores Bueno para servicios y microservicios","title":"Tabla comparativa de seguridad"},{"location":"Ejecucion_depuracion/","text":"EJECUCION Y DEPURACION DEL CODIGO Esta es la documentacion donde voy a ejecutar y a depurar el codigo que hay que hacer en a actividad final Lo primero que hice fue hacer un tree para ver que tenia en mi repositorio y localizar el main_app.py . Ahora lo que voy es a crear un entorno virtual controlado llamado lavadero con: python3 -m venv lavadero Que sirve para ejecutar entornos de python sin da\u00f1ar a los demas proyectos que tengo. Una vez creado lo tengo que activar con el comando: source lavadero/bin/activate simplemente con esto ya estaria activado y se puede ver porque al principio de la shell aparece el nombre del entorno (lavadero) . Ahora quedaria ejecutar el codigo: PYTHONPATH=src python3 src/main_app.py Con este codigo lo ejecutamos pero que es lo que hay en el codigo exactamente. PYTHONPATH=src Con este le estoy diciendo que coja como raiz la carpeta src que es donde tengo los .py a ejecutar. python3 src/main_app.py con esto se ejecuta el archivo principal de la aplicaci\u00f3n que es main_app.py , que est\u00e1 dentro de src/ . Como vemos al final de la ejecucion nos indica que hay un fallo en la linea 83. Ahora o con nano main_app.py como yo hice en el ejemplo o desde visual code vamos a la linea 83 y vemos que el fallo es que no se indica encerado a False como pone en el enunciado del ejemplo 4. Y vemos que ahora todos los ejemplos salen con los resultados que buscabamos.","title":"Ejecucion y depuracion del codigo"},{"location":"Ejecucion_depuracion/#ejecucion-y-depuracion-del-codigo","text":"","title":"EJECUCION Y DEPURACION DEL CODIGO"},{"location":"Ejecucion_depuracion/#esta-es-la-documentacion-donde-voy-a-ejecutar-y-a-depurar-el-codigo-que-hay-que-hacer-en-a-actividad-final","text":"Lo primero que hice fue hacer un tree para ver que tenia en mi repositorio y localizar el main_app.py . Ahora lo que voy es a crear un entorno virtual controlado llamado lavadero con: python3 -m venv lavadero Que sirve para ejecutar entornos de python sin da\u00f1ar a los demas proyectos que tengo. Una vez creado lo tengo que activar con el comando: source lavadero/bin/activate simplemente con esto ya estaria activado y se puede ver porque al principio de la shell aparece el nombre del entorno (lavadero) . Ahora quedaria ejecutar el codigo: PYTHONPATH=src python3 src/main_app.py Con este codigo lo ejecutamos pero que es lo que hay en el codigo exactamente. PYTHONPATH=src Con este le estoy diciendo que coja como raiz la carpeta src que es donde tengo los .py a ejecutar. python3 src/main_app.py con esto se ejecuta el archivo principal de la aplicaci\u00f3n que es main_app.py , que est\u00e1 dentro de src/ . Como vemos al final de la ejecucion nos indica que hay un fallo en la linea 83. Ahora o con nano main_app.py como yo hice en el ejemplo o desde visual code vamos a la linea 83 y vemos que el fallo es que no se indica encerado a False como pone en el enunciado del ejemplo 4. Y vemos que ahora todos los ejemplos salen con los resultados que buscabamos.","title":"Esta es la documentacion donde voy a ejecutar y a depurar el codigo que hay que hacer en a actividad final"},{"location":"pruebas/","text":"PRUEBAS Esta es la documentacion donde estan los 14 test que hay que hacer en a actividad final Lo primero que hice fue copiar a mi codigo los test que el profesor me dio para ir empezando poco a poco: def test1_estado_inicial_correcto(self): \"\"\"Test 1: Verifica que el estado inicial es Inactivocon 0 ingresos.\"\"\" self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertEqual(self.lavadero.ingresos, 0.0) self.assertFalse(self.lavadero.ocupado) self.assertFalse(self.lavadero.prelavado_a_mano) self.assertFalse(self.lavadero.secado_a_mano) self.assertFalse(self.lavadero.encerado) def test2_excepcion_encerado_sin_secado(self): \"\"\"Test 2: Comprueba que encerar sin secado a mano lanza ValueError.\"\"\" # _hacer_lavado: (Prelavado: False, Secado a mano: False, Encerado: True) with self.assertRaises(ValueError): self.lavadero.hacerLavado(False, False, True) def test9_flujo_rapido_sin_extras(self): \"\"\"Test 9: Simula el flujo r\u00e1pido sin opciones opcionales.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 6, 0] # Ejecutar el ciclo completo y obtener las fases fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(prelavado=False, secado=False, encerado=False) # Verificar que las fases obtenidas coinciden con las esperadas self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\") Y ahora hay que ejecutar para ver si los test tienen errores python -m unnittest tests/test_lavadero_unnittest.py -v . El error que nos da en el 1 y en el 2 es basicamente porque esta llamando a _hacer_lavado pero en mi codigo esa funcion de llama hacerLavado . Ahora el error que nos queda esta en el test 9 en que cuando no hay secado a mano se deberia de ir a secado automatico pero se hacia justo lo contrario, simplemente invirtiendo una por otra estaria solucionado. def test3_excepcion_lavado_while_ocupado(self): \"\"\"Test 3: Cuando se intenta hacer un lavado mientras que otro ya est\u00e1 en marcha, se produce una RuntimeError.\"\"\" # Iniciamos un lavado normal (sin extras) self.lavadero.hacerLavado(False, False, False) # Intentamos iniciar otro lavado mientras est\u00e1 ocupado with self.assertRaises(RuntimeError) as context: self.lavadero.hacerLavado(False, False, False) # Opcional: comprobar el mensaje de error self.assertIn(\"ocupado\", str(context.exception)) def test5_ingresos_con_secado(self): \"\"\"Test 5: Si seleccionamos un lavado con secado a mano, los ingresos son 6,00\u20ac.\"\"\" self.lavadero.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=False) while self.lavadero.ocupado: self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 6.00) def test6_ingresos_con_secado_y_encerado(self): \"\"\"Test 6: Si seleccionamos un lavado con secado a mano y encerado, los ingresos son 7,20\u20ac.\"\"\" self.lavadero.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=True) while self.lavadero.ocupado: self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 7.20) def test7_ingresos_con_prelavado_y_secado(self): \"\"\"Test 7: Si seleccionamos un lavado con prelavado a mano y secado a mano, los ingresos son 7,50\u20ac.\"\"\" self.lavadero.hacerLavado(prelavado_a_mano=True, secado_a_mano=True, encerado=False) while self.lavadero.ocupado: self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 7.50) def test8_ingresos_completo_todas_opciones(self): \"\"\"Test 8: Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, los ingresos son 8,70\u20ac.\"\"\" self.lavadero.hacerLavado(prelavado_a_mano=True, secado_a_mano=True, encerado=True) while self.lavadero.ocupado: self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 8.70) Estos son los test 3,5,6,7 y 8 cuando los ejecute todos tenian fallos (No tengo captura porque la shell era muy larga). Uno de los principales fallos era por la funcion de cobrar que estaba invertido el coste de secado y el de encerado simplemente leyendo el comentario que tenia puesto el codigo de lavadero vemos los precios que pone y cambiamos uno por el otro. Y este es el otro fallo que daba es que los tests usan llamadas con keywordsy python solo permite eso si los par\u00e1metros tienen nombres en la definici\u00f3n del m\u00e9todo. Entonces al cambiar esto: Vemos que los test salen todos a ok. Ahora vamos con los ultimos test que son 10,11,12,13 y 14 . def test10_flujo_con_prelavado(self): \"\"\"Test 10: Con prelavado a mano, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 6, 0.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=False, encerado=False ) self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) def test11_flujo_con_secado(self): \"\"\"Test 11: Con secado a mano (sin encerado), el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 0.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=False, secado=True, encerado=False ) self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) def test12_flujo_con_secado_y_encerado(self): \"\"\"Test 12: Con secado a mano y encerado, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=False, secado=True, encerado=True ) self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) def test13_flujo_con_prelavado_y_secado(self): \"\"\"Test 13: Con prelavado a mano y secado a mano (sin encerado), el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 0.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=True, encerado=False ) self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) def test14_flujo_completo_todas_opciones(self): \"\"\"Test 14: Con prelavado a mano, secado a mano y encerado, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=True, encerado=True ) self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) Al ejecutar estos test solo nos daban fallo el 12 y el 14 y daban el mismo problema el problema es que cuando se selecciona encerado (con secado a mano), el lavadero deber\u00eda pasar por la fase 8 (Encerado) y despu\u00e9s terminar (volver a 0). Esto significa que al llegar a la fase SECADO_MANO (7), termina directamente, sin pasar por la fase ENCERADO (8), incluso cuando el cliente ha pagado encerado. Y ahora si vemos que al ejecutar el python -m unnittest tests/test_lavadero_unnittest.py -v por ultima vez compila todo y sale todos los test a ok.","title":"Pruebas"},{"location":"pruebas/#pruebas","text":"","title":"PRUEBAS"},{"location":"pruebas/#esta-es-la-documentacion-donde-estan-los-14-test-que-hay-que-hacer-en-a-actividad-final","text":"Lo primero que hice fue copiar a mi codigo los test que el profesor me dio para ir empezando poco a poco: def test1_estado_inicial_correcto(self): \"\"\"Test 1: Verifica que el estado inicial es Inactivocon 0 ingresos.\"\"\" self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertEqual(self.lavadero.ingresos, 0.0) self.assertFalse(self.lavadero.ocupado) self.assertFalse(self.lavadero.prelavado_a_mano) self.assertFalse(self.lavadero.secado_a_mano) self.assertFalse(self.lavadero.encerado) def test2_excepcion_encerado_sin_secado(self): \"\"\"Test 2: Comprueba que encerar sin secado a mano lanza ValueError.\"\"\" # _hacer_lavado: (Prelavado: False, Secado a mano: False, Encerado: True) with self.assertRaises(ValueError): self.lavadero.hacerLavado(False, False, True) def test9_flujo_rapido_sin_extras(self): \"\"\"Test 9: Simula el flujo r\u00e1pido sin opciones opcionales.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 6, 0] # Ejecutar el ciclo completo y obtener las fases fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(prelavado=False, secado=False, encerado=False) # Verificar que las fases obtenidas coinciden con las esperadas self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\") Y ahora hay que ejecutar para ver si los test tienen errores python -m unnittest tests/test_lavadero_unnittest.py -v . El error que nos da en el 1 y en el 2 es basicamente porque esta llamando a _hacer_lavado pero en mi codigo esa funcion de llama hacerLavado . Ahora el error que nos queda esta en el test 9 en que cuando no hay secado a mano se deberia de ir a secado automatico pero se hacia justo lo contrario, simplemente invirtiendo una por otra estaria solucionado. def test3_excepcion_lavado_while_ocupado(self): \"\"\"Test 3: Cuando se intenta hacer un lavado mientras que otro ya est\u00e1 en marcha, se produce una RuntimeError.\"\"\" # Iniciamos un lavado normal (sin extras) self.lavadero.hacerLavado(False, False, False) # Intentamos iniciar otro lavado mientras est\u00e1 ocupado with self.assertRaises(RuntimeError) as context: self.lavadero.hacerLavado(False, False, False) # Opcional: comprobar el mensaje de error self.assertIn(\"ocupado\", str(context.exception)) def test5_ingresos_con_secado(self): \"\"\"Test 5: Si seleccionamos un lavado con secado a mano, los ingresos son 6,00\u20ac.\"\"\" self.lavadero.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=False) while self.lavadero.ocupado: self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 6.00) def test6_ingresos_con_secado_y_encerado(self): \"\"\"Test 6: Si seleccionamos un lavado con secado a mano y encerado, los ingresos son 7,20\u20ac.\"\"\" self.lavadero.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=True) while self.lavadero.ocupado: self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 7.20) def test7_ingresos_con_prelavado_y_secado(self): \"\"\"Test 7: Si seleccionamos un lavado con prelavado a mano y secado a mano, los ingresos son 7,50\u20ac.\"\"\" self.lavadero.hacerLavado(prelavado_a_mano=True, secado_a_mano=True, encerado=False) while self.lavadero.ocupado: self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 7.50) def test8_ingresos_completo_todas_opciones(self): \"\"\"Test 8: Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, los ingresos son 8,70\u20ac.\"\"\" self.lavadero.hacerLavado(prelavado_a_mano=True, secado_a_mano=True, encerado=True) while self.lavadero.ocupado: self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 8.70) Estos son los test 3,5,6,7 y 8 cuando los ejecute todos tenian fallos (No tengo captura porque la shell era muy larga). Uno de los principales fallos era por la funcion de cobrar que estaba invertido el coste de secado y el de encerado simplemente leyendo el comentario que tenia puesto el codigo de lavadero vemos los precios que pone y cambiamos uno por el otro. Y este es el otro fallo que daba es que los tests usan llamadas con keywordsy python solo permite eso si los par\u00e1metros tienen nombres en la definici\u00f3n del m\u00e9todo. Entonces al cambiar esto: Vemos que los test salen todos a ok. Ahora vamos con los ultimos test que son 10,11,12,13 y 14 . def test10_flujo_con_prelavado(self): \"\"\"Test 10: Con prelavado a mano, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 6, 0.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=False, encerado=False ) self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) def test11_flujo_con_secado(self): \"\"\"Test 11: Con secado a mano (sin encerado), el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 0.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=False, secado=True, encerado=False ) self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) def test12_flujo_con_secado_y_encerado(self): \"\"\"Test 12: Con secado a mano y encerado, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=False, secado=True, encerado=True ) self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) def test13_flujo_con_prelavado_y_secado(self): \"\"\"Test 13: Con prelavado a mano y secado a mano (sin encerado), el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 0.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=True, encerado=False ) self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) def test14_flujo_completo_todas_opciones(self): \"\"\"Test 14: Con prelavado a mano, secado a mano y encerado, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=True, encerado=True ) self.assertEqual( fases_esperadas, fases_obtenidas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) Al ejecutar estos test solo nos daban fallo el 12 y el 14 y daban el mismo problema el problema es que cuando se selecciona encerado (con secado a mano), el lavadero deber\u00eda pasar por la fase 8 (Encerado) y despu\u00e9s terminar (volver a 0). Esto significa que al llegar a la fase SECADO_MANO (7), termina directamente, sin pasar por la fase ENCERADO (8), incluso cuando el cliente ha pagado encerado. Y ahora si vemos que al ejecutar el python -m unnittest tests/test_lavadero_unnittest.py -v por ultima vez compila todo y sale todos los test a ok.","title":"Esta es la documentacion donde estan los 14 test que hay que hacer en a actividad final"},{"location":"sandbox_documentacion/","text":"DOCUMENTACION DE SANDBOX Esta es la documentacion donde esta la ejecucion de sandbox que hay que hacer en a actividad final INSTALAR FIREJAIL Lo primero que hice fue instalar firejail porque en mi kali no venia instalada, en algunas maquinas si viene si cuando la instalaste indicaste que se descargase. PONER FIREJAIL A TRABAJAR Lo primero que hice fue buscar la aplicacion entre mis aplicaciones. La iniciamos Una vez iniciado le damos a configuracion que es la primera applicacion que sale, te pide que digas que quieres ejecutar en tu Sandbox, para nuestro caso la terminal buscando entre las opciones que da no la encontre entonces la abr\u00ed con qterminal . Se nos abre una terminal que es con la que vamos a trabajar. Si abrimos otra terminal con el --list podemos ver los firejail que tengo activos y tambien con --tree sale mas extendido y con mas informacion. EJECUCI\u00d3N DEL C\u00d3DIGO Ya hecha toda la configuracion vamos a la ejecucion del c\u00f3digo. notas.py Por si acaso meti datos en la ejecucion. Tambien lo hice con lavadero, empece con el pero lo deje de lado al no entender porque me daba error, pero vi que el error que me daba era en la linea 83 fui a ella y vi que los demas ejemplos que habia en el codigo habia una linea que ponia encerado=False y que en el ejemplo 4 no estaba, puse lo msimo en el ejemplo 4 y lo ejecute y ya si me funcionaba.","title":"Sandbox"},{"location":"sandbox_documentacion/#documentacion-de-sandbox","text":"","title":"DOCUMENTACION DE SANDBOX"},{"location":"sandbox_documentacion/#esta-es-la-documentacion-donde-esta-la-ejecucion-de-sandbox-que-hay-que-hacer-en-a-actividad-final","text":"","title":"Esta es la documentacion donde esta la ejecucion de sandbox que hay que hacer en a actividad final"},{"location":"sandbox_documentacion/#instalar-firejail","text":"Lo primero que hice fue instalar firejail porque en mi kali no venia instalada, en algunas maquinas si viene si cuando la instalaste indicaste que se descargase.","title":"INSTALAR FIREJAIL"},{"location":"sandbox_documentacion/#poner-firejail-a-trabajar","text":"Lo primero que hice fue buscar la aplicacion entre mis aplicaciones. La iniciamos Una vez iniciado le damos a configuracion que es la primera applicacion que sale, te pide que digas que quieres ejecutar en tu Sandbox, para nuestro caso la terminal buscando entre las opciones que da no la encontre entonces la abr\u00ed con qterminal . Se nos abre una terminal que es con la que vamos a trabajar. Si abrimos otra terminal con el --list podemos ver los firejail que tengo activos y tambien con --tree sale mas extendido y con mas informacion.","title":"PONER FIREJAIL A TRABAJAR"},{"location":"sandbox_documentacion/#ejecucion-del-codigo","text":"Ya hecha toda la configuracion vamos a la ejecucion del c\u00f3digo. notas.py Por si acaso meti datos en la ejecucion. Tambien lo hice con lavadero, empece con el pero lo deje de lado al no entender porque me daba error, pero vi que el error que me daba era en la linea 83 fui a ella y vi que los demas ejemplos que habia en el codigo habia una linea que ponia encerado=False y que en el ejemplo 4 no estaba, puse lo msimo en el ejemplo 4 y lo ejecute y ya si me funcionaba.","title":"EJECUCI\u00d3N DEL C\u00d3DIGO"}]}